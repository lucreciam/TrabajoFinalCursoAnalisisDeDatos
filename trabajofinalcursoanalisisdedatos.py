# -*- coding: utf-8 -*-
"""TrabajoFinalCursoAnalisisDeDatos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d_qBYltugQ2-vYyuFMhSGAE8SpkyO4o8

# PROYECTO FINAL

##ANALISIS DE ARCHIVOS CSV
- Para determinar el tratamiento que debemos dar a cada archivo realizamos un analisis general de cada uno:

1.   Archivo ecommerce_products_dataset:
  *   ("products") información sobre los productos disponibles.
  *   Los encabezados de las columnas sugieren que incluye detalles como el nombre del producto, la categoría, la longitud y la descripción del producto, entre otros.
  *   Este archivo se utilizará para identificar la categoría de productos más vendida.

2.   Archivo ecommerce_orders_dataset:
  *   ("orders") información sobre los pedidos realizados.
  *   Los encabezados de las columnas incluyen detalles como el ID del pedido, el ID del cliente, el estado del pedido y fechas relacionadas con el proceso de pedido.
  *   Este archivo se utilizará para calcular el número total de pedidos realizados y para analizar el comportamiento de compra de los clientes.

3. Archivo ecommerce_order_payments_dataset:
  *   ("order_payments") información sobre los pagos
  *   Los encabezados de las columnas incluyen detalles como el método de pago, el valor del pago y el número de cuotas.
  *   Este archivo se utilizará para calcular el promedio de valor de pago por pedido.

4. Archivo ecommerce_customers_dataset:
  *   ("customers") sugiere que contiene información sobre los clientes.
  *   Los encabezados de las columnas incluyen detalles como el ID del cliente, el código postal, la ciudad y el estado del cliente.
  *   Este archivo se utilizará para contar el número total de clientes únicos.

5. Archivo ecommerce_order_items_dataset:
*   ("order_items") información sobre los productos incluidos en cada pedido.
*   Los encabezados de las columnas incluyen detalles como el ID del pedido, el ID del producto, el precio y el valor del envío.
*   Este archivo se utilizará para calcular métricas relacionadas con las ventas y los productos.

Al considerar estos factores, podemos determinar qué operaciones realizar en cada archivo para cumplir con los requisitos del trabajo.

##TRATAMIENTO DE ARCHIVOS CSV

Importacion de la libreria
"""

!pip install pandas==2.2.2

import pandas as pd
import os

"""Defino una funcion para la limpieza de los archivos"""

def limpiar_analizar_datos(df):
    """
    Esta función carga un DataFrame, realiza tareas de limpieza y análisis, y devuelve el DataFrame limpio.

    Parámetros:
        df (DataFrame): El DataFrame que se va a limpiar y analizar.

    Retorna:
        DataFrame: El DataFrame limpio.
    """
    # Tamaño del DataFrame
    print("Tamaño del DataFrame:")
    print(df.shape)
    print("----------------------------------------")

    # Análisis de Tipos de Datos
    print("Análisis de Tipos de Datos:")
    print(df.info())
    print("----------------------------------------")

    # Recuento de Valores Nulos
    print("Recuento de Valores Nulos:")
    print(df.isnull().sum())
    print("----------------------------------------")

    # Recuento de Valores Duplicados
    print("Recuento de Valores Duplicados:")
    print(df.duplicated().sum())
    print("----------------------------------------")

    # Análisis de Estadísticas Descriptivas (para columnas numéricas)
    print("Estadísticas Descriptivas:")
    print(df.describe())
    print("----------------------------------------")

    return df

"""### ORDERS


"""

#Importar dataset como Dataframe y visualizar los 5 primeros datos del dataset
df_orders = pd.read_csv("https://raw.githubusercontent.com/lucreciam/TrabajoFinalCursoAnalisisDeDatos/main/ecommerce_orders_dataset.csv")
df_orders.head()

# Llamar a la función para limpiar y analizar los datos
df_orders = limpiar_analizar_datos(df_orders)

"""### CUSTOMERS

"""

#Importar dataset como Dataframe y visualizar los 5 primeros datos del dataset
df_customers = pd.read_csv("https://raw.githubusercontent.com/lucreciam/TrabajoFinalCursoAnalisisDeDatos/main/ecommerce_customers_dataset.csv")
df_customers.head()

# Llamar a la función para limpiar y analizar los datos
df_customers = limpiar_analizar_datos(df_customers)

"""### PAYMENTS"""

#Importar dataset como Dataframe y visualizar los 5 primeros datos del dataset
df_payments = pd.read_csv("https://raw.githubusercontent.com/lucreciam/TrabajoFinalCursoAnalisisDeDatos/main/ecommerce_order_payments_dataset.csv")
df_payments.head()

# Llamar a la función para limpiar y analizar los datos
df_payments = limpiar_analizar_datos(df_payments)

"""### PRODUCTS"""

#Importar dataset como Dataframe y visualizar los 5 primeros datos del dataset
df_products = pd.read_csv("https://raw.githubusercontent.com/lucreciam/TrabajoFinalCursoAnalisisDeDatos/main/ecommerce_products_dataset.csv")
df_products.head()

# Llamar a la función para limpiar y analizar los datos
df_products = limpiar_analizar_datos(df_products)

"""### ORDERS ITEMS"""

#Importar dataset como Dataframe y visualizar los 5 primeros datos del dataset
df_order_items = pd.read_csv("https://raw.githubusercontent.com/lucreciam/TrabajoFinalCursoAnalisisDeDatos/main/ecommerce_order_items_dataset.csv")
df_order_items.head()

# Llamar a la función para limpiar y analizar los datos
df_order_items = limpiar_analizar_datos(df_order_items)

"""# TRANSFORMACION DE DATAFRAMES

## FUNCIONES
"""

# Función para transformar fechas
def transformarFechas(df, columnas_fechas):
    df[columnas_fechas] = df[columnas_fechas].apply(pd.to_datetime)
    return df

# Función para transformar columnas a tipo string
def transformarString(df, columnas_string):
    for columna in columnas_string:
        df[columna] = df[columna].astype("string")
    return df

# Función para convertir a mayúsculas
def convertirMayusculas(df, columna):
    df[columna] = df[columna].str.upper()
    return df

# Función para convertir a minúsculas
def convertirMinusculas(df, columna):
    df[columna] = df[columna].str.lower()
    return df

"""## ORDERS"""

# Porcentaje de nulos en cada columna
null_percentages_orders = (df_orders.isnull().sum() / len(df_orders)) * 100

# Filtramos las columnas con menos del 10% de valores nulos
columns_to_keep_orders = null_percentages_orders[null_percentages_orders <= 10].index

# Eliminamos las filas con nulos solo en las columnas seleccionadas
df_orders = df_orders.dropna(subset=columns_to_keep_orders).copy()

# Lista de columnas que contienen fechas
columnas_fechas_orders = ['order_purchase_timestamp', 'order_approved_at', 'order_delivered_carrier_date', 'order_delivered_customer_date', 'order_estimated_delivery_date']

# Aplicamos nuestra funcion conversora de fechas
df_orders = transformarFechas(df_orders, columnas_fechas_orders)

# Lista de columnas a transformar en string
columnas_string_orders = ["order_id","customer_id","order_status"]

# Aplicamos nuestra funcion conversora de string
df_orders = transformarString(df_orders, columnas_string_orders)

# Revisamos que los tipos de datos sean correctos
df_orders.info()

# Aplicamos la conversion a minúsculas
df_orders = convertirMinusculas(df_orders, "order_status")

"""## PRODUCTS"""

# Porcentaje de nulos en cada columna
null_percentages_products = (df_products.isnull().sum() / len(df_products)) * 100

print("Porcentaje de nulos en cada columna:")
print(null_percentages_products)

# Filtramos las columnas con menos del 10% de valores nulos
columns_to_keep_products = null_percentages_products[null_percentages_products <= 10].index

print("Columnas seleccionadas:")
print(columns_to_keep_products)

# Eliminamos las filas con nulos solo en las columnas seleccionadas
df_products.dropna(subset=columns_to_keep_products, inplace=True)

# Chequeo cantidad de null
print("Recuento de valores nulos después de la eliminación:")
print(df_products.isnull().sum())

# Lista de columnas a transformar en string
columnas_string_products = ["product_id", "product_category_name"]

# Aplicamos nuestra función conversora de string
df_products = transformarString(df_products, columnas_string_products)

# Revisamos que los tipos de datos sean correctos
print("Información del DataFrame después de la conversión:")
print(df_products.info())

# Aplicamos la conversión a minúsculas
df_products = convertirMinusculas(df_products, "product_category_name")

"""## CUSTOMERS"""

# Lista de columnas a transformar en string
columnas_string_customers = ["customer_id", "customer_unique_id", "customer_zip_code_prefix", "customer_city", "customer_state"]

# Aplicamos nuestra función conversora de string
df_customers = transformarString(df_customers, columnas_string_customers)

# Revisamos que los tipos de datos sean correctos
print("Información del DataFrame después de la conversión:")
print(df_customers.info())

# Aplicamos la conversión a minúsculas
df_customers = convertirMinusculas(df_customers, "customer_city")

# Aplicamos la conversión a mayúsculas
df_customers = convertirMayusculas(df_customers, "customer_state")

"""## PAYMENTS"""

# Lista de columnas a transformar en string
columnas_string_order_payments = ["order_id", "payment_type"]

# Aplicamos nuestra función conversora de string
df_order_payments = transformarString(df_order_payments, columnas_string_order_payments)

# Aplicamos la conversión a minúsculas
df_order_payments = convertirMinusculas(df_order_payments, "payment_type")

"""## ORDER ITEMS"""

# Lista de columnas que contienen fechas
columnas_fechas_order_items = ['shipping_limit_date']

# Aplicamos nuestra función conversora de fechas
df_order_items = transformarFechas(df_order_items, columnas_fechas_order_items)

# Lista de columnas a transformar en string
columnas_string_order_items = ["order_id", "order_item_id", "product_id", "seller_id", "shipping_limit_date"]

# Aplicamos nuestra función conversora de string
df_order_items = transformarString(df_order_items, columnas_string_order_items)

"""# ANALISIS

Siguiendo con el analisis que hice al comienzo, se decide realizar esta funcion para proporcionar de manera rapida y sencilla informacion basica sobre los dataframes que se estuvieron trabajando.

*   Selección de columnas numéricas y cualitativas: identifica las columnas numéricas y cualitativas en el DataFrame utilizando los métodos select_dtypes de Pandas. Esto permite un análisis separado de variables cuantitativas (como números enteros y flotantes) y cualitativas (como cadenas de texto).
*   Análisis de variables cuantitativas: Si el DataFrame contiene columnas numéricas, la función imprime un resumen estadístico básico de esas columnas utilizando el método describe de Pandas. Esto proporciona información útil como el recuento de valores no nulos, la media, la desviación estándar, el valor mínimo, los percentiles y el valor máximo de cada columna numérica.
*   Análisis de variables cualitativas: Si el DataFrame contiene columnas de tipo string u objeto, la función también imprime un resumen de esas columnas utilizando describe. Esto proporciona recuentos de valores únicos, el valor más frecuente (mode) y la frecuencia de ese valor, lo que puede ser útil para comprender la distribución de los datos cualitativos.
*   Manejo de DataFrames vacíos: La función incluye una verificación para asegurarse de que haya columnas numéricas y/o cualitativas antes de intentar realizar los análisis correspondientes. Esto evita errores si el DataFrame no contiene ninguno de estos tipos de columnas.
"""

def analisisDataFrames(df):
    print("----------")
    print("Análisis variables cuantitativas")
    columnas_numericas = df.select_dtypes(include=['int', 'float']).columns
    if not columnas_numericas.empty:
        print(df[columnas_numericas].describe())
    else:
        print("No se encontraron variables cuantitativas en este DataFrame.")

    print("----------")
    print("Análisis variables cualitativas")
    columnas_string = df.select_dtypes(include=['string']).columns
    if not columnas_string.empty:
        print(df[columnas_string].describe())
    else:
        print("No se encontraron variables cualitativas en este DataFrame.")

"""### ORDERS"""

#Aplicamos la función
analisisDataFrames(df_orders)

"""#### Análisis de variables cualitativas:

*   order_id: Hay un total de 96,461 registros únicos para los IDs de pedido.
*   customer_id: También hay 96,461 registros únicos para los IDs de cliente.
*   order_status: Este campo muestra que hay dos estados principales de pedidos: "delivered" (entregado) La mayoría de los pedidos, específicamente 96,455 de ellos, se encuentran en el estado "delivered".

#### Observaciones:
La mayoría de los pedidos están en el estado "delivered", lo que sugiere que la mayoría de los pedidos han sido entregados correctamente.
Todos los IDs de pedido y de cliente son únicos, lo que indica que cada pedido y cliente tiene una identificación única en el conjunto de datos.

## PRODUCTS
"""

#Aplicamos la función
analisisDataFrames(df_products)

"""#### Análisis de variables cuantitativas:
*   product_photos_qty: En promedio, los productos tienen alrededor de 2.19 fotos, con un mínimo de 1 y un máximo de 20.
*   product_weight_g: El peso promedio de los productos es aproximadamente 2276.96 gramos, con un mínimo de 0 y un máximo de 40425.

#### Análisis de variables cualitativas:
*   product_id: Hay un total de 32,340 registros únicos para los IDs de producto.
*   product_category_name: Hay un total de 73 categorías únicas de productos.

#### Observaciones:
*   La mayoría de las variables cuantitativas tienen un rango bastante amplio, lo que sugiere que hay una gran variabilidad en las características físicas de los productos.
*   Se podría profundizar más en el análisis de la distribución de las categorías de productos para comprender mejor la composición del inventario.
"""

#Analizamos las categorias
df_products["product_category_name"].value_counts()

"""1.   Productos para el hogar dominantes: Las categorías relacionadas con el hogar, como "cama_mesa_banho" y "utilidades_domesticas", son las más populares, lo que sugiere una alta demanda de artículos para el hogar.
2.   Efecto de las imágenes: Se observa que la mayoría de los productos tienen una sola foto en la descripción, lo que podría indicar que una sola imagen es suficiente para atraer a los compradores. 3.   Variedad de categorías: Aunque las categorías relacionadas con el hogar dominan el conjunto de datos, también se observa una amplia variedad de categorías,

## ORDERS ITEMS
"""

#Aplicamos la función
analisisDataFrames(df_order_items)

"""#### Análisis de variables cuantitativas:
*   Precio (price): El precio medio de los productos es de aproximadamente 120.65 unidades monetarias, con un rango que va desde 0.85 hasta 6735 unidades. La dispersión de los datos es alta, como lo indica la desviación estándar de 183.63.
*   Valor del flete (freight_value): El valor medio del flete es de aproximadamente 19.99 unidades monetarias, con un rango que va desde 0 hasta 409.68 unidades. La desviación estándar de 15.81 indica una dispersión moderada de los datos.

#### Análisis de variables cualitativas:
*   ID del artículo del pedido (order_item_id): La mayoría de los pedidos (aproximadamente el 87.6%) contienen un solo artículo, lo que sugiere que la mayoría de los clientes realizan compras de productos individuales.
*   Fecha límite de envío (shipping_limit_date): La fecha límite de envío más común es el 21 de julio de 2017, que aparece en 21 pedidos. Esto sugiere que podría haber habido algún evento promocional o campaña de marketing durante ese período que generó un aumento en las ventas.

#### Observaciones
*   La mayoría de los pedidos (87.6%) consisten en un solo artículo. Esto sugiere que la mayoría de los clientes realizan compras individuales en lugar de pedidos múltiples.

## CUSTOMERS
"""

#Aplicamos la función
analisisDataFrames(df_customers)

"""#### Análisis de variables cualitativas:
*   customer_zip_code_prefix: Hay 14,994 códigos postales únicos en el conjunto de datos, lo que sugiere una variedad de ubicaciones geográficas para los clientes.
*   customer_city: Se registran 4,119 ciudades únicas en el conjunto de datos, lo que indica la diversidad de áreas urbanas y rurales donde residen los clientes.


"""

#Realizamos un analisis por regiones de los compradores
df_customers["customer_state"].value_counts()

"""Podemos observar que el estado de São Paulo (SP) tiene la mayor cantidad de compradores, seguido de Río de Janeiro (RJ) y Minas Gerais (MG).

## PAYMENTS
"""

#Aplicamos la función
analisisDataFrames(df_order_payments)

"""#### Analisis de variables cuantitativas:
*   payment_installments: La mayoría de los pagos se realizan en un solo pago. Sin embargo, el número máximo de cuotas es de 24, lo que sugiere que algunos clientes optan por pagar en múltiples cuotas.

#### Analisis de variables cualitativas:
*   payment_type: El método de pago más común es mediante tarjeta de crédito, seguido por boleto bancario, voucher de regalo, debit card y transferencia bancaria.

# Nuevos DATAFRAMES

Para generar los nuevos DataFrames, primero realizamos un proceso de fusión (merge) entre los conjuntos de datos originales.
"""

directorio_actual = os.getcwd()

print("El directorio actual es:", directorio_actual)

# Crear la carpeta 'dataset_generados' si no existe
if not os.path.exists('dataset_generados'):
    os.makedirs('dataset_generados')

# Fusionar el DataFrame de Órdenes y Pagos
df_merge_orders_payments = pd.merge(df_orders, df_order_payments, how="inner", on="order_id")

# Simplificar la información
df_merge_orders_payments.drop(['customer_id', 'order_approved_at', 'order_delivered_carrier_date',
                               'order_delivered_customer_date', 'order_estimated_delivery_date'],
                              axis=1, inplace=True)

# Exportar como CSV
df_merge_orders_payments.to_csv("dataset_generados/orders_payments.csv", index=False)

# Fusionar el DataFrame de Ítems de Orden y Productos
df_merge_order_items_products = pd.merge(df_order_items, df_products, how="inner", on="product_id")

# Simplificar la información
df_merge_order_items_products.drop(['product_id', 'seller_id', 'shipping_limit_date'],
                                    axis=1, inplace=True)

# Exportar como CSV
df_merge_order_items_products.to_csv("dataset_generados/order_items_products.csv", index=False)

"""## ANALISIS Y FUSION DE DATAFRAMES

La fusión de los DataFrames se realiza para combinar la información relevante de diferentes conjuntos de datos en un solo DataFrame, lo que facilita el análisis conjunto y la generación de informes. Por ejemplo:



*   Al fusionar el DataFrame de Órdenes con el de Pagos, obtenemos un conjunto de datos que incluye información sobre las órdenes y los pagos asociados, lo que nos permite analizar el comportamiento de compra de los clientes y los patrones de pago.
*   Al fusionar el DataFrame de Ítems de Orden con el de Productos, creamos un conjunto de datos que contiene detalles sobre los productos comprados en cada orden, lo que nos permite analizar las ventas de productos y las preferencias de los clientes.
"""